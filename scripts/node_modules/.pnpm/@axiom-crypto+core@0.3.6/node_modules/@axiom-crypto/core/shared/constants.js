"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateConstants = exports.ContractEvents = exports.setVersionData = exports.Versions = void 0;
const mainnet_1 = require("./chainConfig/mainnet");
const goerli_1 = require("./chainConfig/goerli");
const utils_1 = require("./utils");
exports.Versions = ["v0", "v0_2", "v1"];
function setVersionData(chainId, version, mock) {
    let versionData;
    switch (chainId) {
        case 1:
            versionData = (0, utils_1.deepCopyObject)(mainnet_1.versionDataMainnet);
            if (mock) {
                updateConstants(versionData, version, mainnet_1.versionOverrideMainnetMock[version]);
            }
            break;
        case 5:
            versionData = (0, utils_1.deepCopyObject)(goerli_1.versionDataGoerli);
            if (mock) {
                updateConstants(versionData, version, goerli_1.versionOverrideGoerliMock[version]);
            }
            break;
        default:
            throw new Error(`Unsupported chainId: ${chainId}`);
    }
    return versionData;
}
exports.setVersionData = setVersionData;
exports.ContractEvents = Object.freeze({
    QueryInitiatedOnchain: "QueryInitiatedOnchain",
    QueryFulfilled: "QueryFulfilled",
});
/// Update constants using the same nested object structure as the versionData variable.
/// Pass the updateObject in as an override when initializing Axiom.
function updateConstants(versionData, version, updateObject) {
    const versionUpdateObject = {
        [version]: updateObject
    };
    return updateConstantsRecursive(Object.assign({}, versionData), versionUpdateObject);
}
exports.updateConstants = updateConstants;
function updateConstantsRecursive(versionMem, updateMem) {
    const keys = Object.keys(updateMem);
    for (const key of keys) {
        if (versionMem[key] === undefined) {
            console.log("versionData does not have key", key);
            continue;
        }
        if (typeof updateMem[key] !== "object") {
            versionMem[key] = updateMem[key];
            continue;
        }
        updateConstantsRecursive(versionMem[key], updateMem[key]);
    }
    return versionMem;
}
//# sourceMappingURL=constants.js.map