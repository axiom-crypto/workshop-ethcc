"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deepCopyObject = exports.sortSlot = exports.sortAddress = exports.sortBlockNumber = exports.concatHexStrings = exports.getAccountData = exports.getFullBlock = exports.shortenedHex = exports.stripZerosLeft = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
function stripZerosLeft(hex) {
    if (hex.substring(0, 2) === '0x') {
        const hexSubstr = hex.substring(2, hex.length);
        const stripped = hexSubstr.replace(/^0+/, '');
        return `0x${stripped}`;
    }
    return hex.replace(/^0+/, '');
}
exports.stripZerosLeft = stripZerosLeft;
function shortenedHex(num) {
    return stripZerosLeft(ethers_1.ethers.toBeHex(num));
}
exports.shortenedHex = shortenedHex;
function getFullBlock(blockNumber, provider) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const fullBlock = yield provider.send('eth_getBlockByNumber', [shortenedHex(blockNumber), true]);
        return fullBlock;
    });
}
exports.getFullBlock = getFullBlock;
function getAccountData(blockNumber, address, slots, provider) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const accountData = yield provider.send('eth_getProof', [address, slots, shortenedHex(blockNumber)]);
        return accountData;
    });
}
exports.getAccountData = getAccountData;
function concatHexStrings(...args) {
    return `0x${args.map((s) => {
        if (s.substring(0, 2) === '0x') {
            return s.substring(2, s.length);
        }
        else {
            return s;
        }
    }).join('')}`;
}
exports.concatHexStrings = concatHexStrings;
function sortBlockNumber(a, b) {
    return a - b;
}
exports.sortBlockNumber = sortBlockNumber;
;
function sortAddress(a, b) {
    if (a === undefined && b === undefined) {
        return 0;
    }
    else if (a === undefined) {
        return -1;
    }
    else if (b === undefined) {
        return 1;
    }
    return parseInt(a, 16) - parseInt(b, 16);
}
exports.sortAddress = sortAddress;
;
function sortSlot(a, b) {
    if (a === undefined && b === undefined) {
        return 0;
    }
    else if (a === undefined) {
        return -1;
    }
    else if (b === undefined) {
        return 1;
    }
    return parseInt(a.toString(), 16) - parseInt(b.toString(), 16);
}
exports.sortSlot = sortSlot;
;
// Deep copy any object with nested objects. Will not deep copy functions inside the object.
function deepCopyObject(obj) {
    return JSON.parse(JSON.stringify(obj));
}
exports.deepCopyObject = deepCopyObject;
//# sourceMappingURL=utils.js.map