"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeRowHash = exports.encodeQueryData = exports.encodeQuery = void 0;
const ethers_1 = require("ethers");
function encodeQuery(length, blockNumber, address, slot, value) {
    const queryTypes = ["uint8", "uint32", "address", "uint256", "uint256"];
    const queryData = [length, blockNumber, address, slot, value];
    // Only encode the first `length + 1` elements
    const encodedQuery = ethers_1.ethers.solidityPacked(queryTypes.slice(0, length + 1), queryData.slice(0, length + 1));
    return encodedQuery;
}
exports.encodeQuery = encodeQuery;
function encodeQueryData(versionIdx, length, encodedQueries) {
    const encodedQueryData = ethers_1.ethers.solidityPacked(["uint8", "uint32", "bytes[]"], [versionIdx, length, encodedQueries]);
    return encodedQueryData;
}
exports.encodeQueryData = encodeQueryData;
function encodeRowHash(blockNumber, address, slot) {
    let length = 3;
    const addressValue = address !== null && address !== void 0 ? address : ethers_1.ZeroAddress;
    const slotValue = slot !== null && slot !== void 0 ? slot : 0;
    if (slot === undefined) {
        length = 2;
    }
    if (address === undefined) {
        length = 1;
    }
    const packed = ethers_1.ethers.solidityPacked(["uint8", "uint32", "address", "uint256"], [length, blockNumber, addressValue, ethers_1.ethers.toBeHex(slotValue, 32)]);
    return ethers_1.ethers.keccak256(packed);
}
exports.encodeRowHash = encodeRowHash;
//# sourceMappingURL=encoder.js.map