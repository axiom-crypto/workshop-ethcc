"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryBuilder = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const response_1 = require("./response");
const encoder_1 = require("./encoder");
const internalConfig_1 = require("../core/internalConfig");
const utils_1 = require("../shared/utils");
const validate_1 = require("./validate");
const merkletreejs_1 = tslib_1.__importDefault(require("merkletreejs"));
class QueryBuilder {
    constructor(config) {
        this.queries = [];
        this.responseTree = undefined;
        this.config = new internalConfig_1.InternalConfig(config);
        this.maxSize = this.config.getConstants().Values.MaxQuerySize;
        if ((this.maxSize & (this.maxSize - 1)) !== 0) {
            throw new Error("QueryBuilder maxSize must be a power of 2");
        }
    }
    /// Appends a `QueryRow` to the current `QueryBuilder` instance. If the `QueryBuilder`
    /// has reached its maximum size, or if validation for that `QueryRow` fails then an 
    /// error will be thrown.
    append(queryRow) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const processedRow = yield this.processQueryRow(queryRow);
            yield (0, validate_1.validateQueryRow)(this.config.provider, processedRow);
            this.queries.push(processedRow);
        });
    }
    /// Appends a `QueryRow` to the current `QueryBuilder` instance without validating the 
    /// the values first. If there are invalid values (such as the account address being an 
    /// empty account at the specified block number), then the proof generation of the Query 
    /// will fail after submitting the transaction, making it impossible to fulfill the 
    /// Query on-chain.
    appendWithoutValidation(queryRow) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const processedRow = yield this.processQueryRow(queryRow);
            this.queries.push(processedRow);
        });
    }
    /// Gets the current number of `QueryRow`s appended to the instance of `QueryBuilder`.
    getCurrentSize() {
        return this.queries.length;
    }
    /// Gets the number of `QueryRow`s that can still be appended
    getRemainingSize() {
        return this.maxSize - this.queries.length;
    }
    /// Gets the maximum number of `QueryRow`s that the current instance of `QueryBuilder`
    /// supports
    getMaxSize() {
        return this.maxSize;
    }
    /// Gets the current `QueryRow` values as a formatted string in the order that they
    /// were appended
    asFormattedString() {
        return this.formatQueries(this.queries);
    }
    /// Sorts the queries first before formatting the output string
    asSortedFormattedString() {
        const sortedQueries = this.sortQueries();
        return this.formatQueries(sortedQueries);
    }
    /// Gets the ResponseTree for the current set of queries if `build()` has been called
    getResponseTree() {
        return this.responseTree;
    }
    /// Builds the query response and query data to be sent to the Axiom contract.
    build() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.queries.length === 0) {
                throw new Error("Cannot build query response and query data with no queries");
            }
            const sortedQueries = this.sortQueries();
            const keccakQueryResponse = yield this.buildQueryResponse(sortedQueries);
            const query = this.buildQueryData(sortedQueries);
            const queryHash = (0, ethers_1.keccak256)(query);
            return {
                keccakQueryResponse,
                queryHash,
                query,
            };
        });
    }
    /// Processes an input `QueryRow` and gets a value from the provider if necessary
    processQueryRow(queryRow) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.queries.length >= this.maxSize) {
                throw new Error(`QueryBuilder has reached its maximum size of ${this.maxSize}. Either reduce the number of queries or pass in a larger size to QueryBuilder.`);
            }
            if (queryRow.address === undefined && queryRow.slot !== undefined) {
                throw new Error("If `slot` is specified, then `address` must not be null");
            }
            // Ensure valid address
            if (queryRow.address !== undefined) {
                if (queryRow.address.match(/^0x[0-9a-fA-F]{40}$/) === null) {
                    throw new Error(`Invalid address format for: ${queryRow.address}`);
                }
            }
            if (!queryRow.value) {
                if (queryRow.address !== undefined && queryRow.slot !== undefined) {
                    // Note that this may fail silently if the archive node is not able to get the value at the slot
                    queryRow.value = yield this.config.provider.getStorage(queryRow.address, queryRow.slot, queryRow.blockNumber);
                }
                else {
                    queryRow.value = undefined;
                }
            }
            return queryRow;
        });
    }
    /// Sorts queries in order of blockNumber, address, and slot
    sortQueries() {
        return this.queries.sort((a, b) => {
            // Sorts by blockNumber, then address, then slot
            return ((0, utils_1.sortBlockNumber)(a.blockNumber, b.blockNumber) ||
                (0, utils_1.sortAddress)(a.address, b.address) ||
                (0, utils_1.sortSlot)(a.slot, b.slot));
        });
    }
    /// Formats queries into a pretty-printable string
    formatQueries(queries) {
        let str = "";
        for (let i = 0; i < queries.length; i++) {
            const query = queries[i];
            str += `query: ${i}`;
            if (query.blockNumber !== undefined) {
                str += `, blockNumber: ${query.blockNumber}`;
            }
            if (query.address !== undefined) {
                str += `, address: ${query.address}`;
            }
            if (query.slot !== undefined) {
                str += `, slot: ${query.slot}`;
            }
            if (query.value !== undefined) {
                str += `, value: ${query.value}`;
            }
            str += `\n`;
        }
        return str;
    }
    /// Builds a queryResponse from the sorted queries
    buildQueryResponse(sortedQueries) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const queryData = yield this.getQueryDataFromRows(sortedQueries);
            const responseTree = this.buildResponseTree(queryData);
            this.responseTree = responseTree;
            // Calculate the merkle root for each column
            const blockResponseRoot = responseTree.blockTree.getHexRoot();
            const accountResponseRoot = responseTree.accountTree.getHexRoot();
            const storageResponseRoot = responseTree.storageTree.getHexRoot();
            // Calculate the queryResponse
            const queryResponse = (0, ethers_1.keccak256)((0, utils_1.concatHexStrings)(blockResponseRoot, accountResponseRoot, storageResponseRoot));
            return queryResponse;
        });
    }
    buildResponseTree(data) {
        // Calculate each of the column responses and append them to each column
        let blockResponseColumn = [];
        let accountResponseColumn = [];
        let storageResponseColumn = [];
        const rowHashMap = new Map(data.map((row, i) => [row.rowHash, i]));
        for (const query of data) {
            // Calculate the keccakBlockResponse
            const blockResponse = (0, response_1.getBlockResponse)(query.blockHash, query.blockNumber);
            blockResponseColumn.push(blockResponse);
            const address = query.address;
            if (!address) {
                accountResponseColumn.push(ethers_1.ZeroHash);
                storageResponseColumn.push(ethers_1.ZeroHash);
            }
            else {
                const nonce = query.nonce;
                const balance = query.balance;
                const storageHash = query.storageHash;
                const codeHash = query.codeHash;
                if (nonce === undefined ||
                    balance === undefined ||
                    storageHash === undefined ||
                    codeHash === undefined) {
                    throw new Error(`Could not find account data for ${address} at block ${query.blockNumber}`);
                }
                // Calculate keccakFullAccountResponse
                const fullAccountResponse = (0, response_1.getFullAccountResponse)(query.blockNumber, address, nonce, balance, storageHash, codeHash);
                accountResponseColumn.push(fullAccountResponse);
                const slot = query.slot;
                if (!slot) {
                    storageResponseColumn.push(ethers_1.ZeroHash);
                }
                else {
                    const value = query.value;
                    if (!value) {
                        throw new Error(`Could not find storage data for slot ${slot} in account ${address} at block ${query.blockNumber}`);
                    }
                    // Calculate keccakFullStorageResponse
                    const fullStorageResponse = (0, response_1.getFullStorageResponse)(query.blockNumber, address, slot, value);
                    storageResponseColumn.push(fullStorageResponse);
                }
            }
        }
        // Fill in the remaining unused rows in the columns with zeros
        const numUnused = this.maxSize - data.length;
        blockResponseColumn = blockResponseColumn.concat(Array(numUnused).fill(ethers_1.ZeroHash));
        accountResponseColumn = accountResponseColumn.concat(Array(numUnused).fill(ethers_1.ZeroHash));
        storageResponseColumn = storageResponseColumn.concat(Array(numUnused).fill(ethers_1.ZeroHash));
        const blockTree = new merkletreejs_1.default(blockResponseColumn, ethers_1.keccak256);
        const accountTree = new merkletreejs_1.default(accountResponseColumn, ethers_1.keccak256);
        const storageTree = new merkletreejs_1.default(storageResponseColumn, ethers_1.keccak256);
        return {
            blockTree,
            accountTree,
            storageTree,
            rowHashMap,
            data,
        };
    }
    getQueryDataFromRows(sortedQueries) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Collapse blockNumber, account, and slot into hash table keys to reduce total
            // number of JSON-RPC calls
            let blockNumberToBlock = {};
            let blockNumberAccountToAccount = {};
            let blockNumberAccountStorageToValue = {};
            for (let i = 0; i < sortedQueries.length; i++) {
                const blockNumber = sortedQueries[i].blockNumber;
                blockNumberToBlock[`${blockNumber}`] = null;
                const address = sortedQueries[i].address;
                if (address !== undefined) {
                    blockNumberAccountToAccount[`${blockNumber},${address}`] = null;
                }
                const slot = sortedQueries[i].slot;
                if (address !== undefined &&
                    slot !== undefined &&
                    sortedQueries[i].value !== undefined) {
                    blockNumberAccountStorageToValue[`${blockNumber},${address},${slot}`] =
                        sortedQueries[i].value;
                }
            }
            // Get all of the block hashes
            for (const blockNumberStr of Object.keys(blockNumberToBlock)) {
                const blockNumber = parseInt(blockNumberStr);
                const block = yield this.config.provider.getBlock(blockNumber);
                if (block === null || block.hash === null) {
                    throw new Error(`Could not get block ${blockNumber} from provider ${this.config.providerUri}`);
                }
                blockNumberToBlock[blockNumber] = block;
            }
            // Get all of the data for the accounts
            for (const blockNumberAccountStr of Object.keys(blockNumberAccountToAccount)) {
                const [blockNumberStr, address] = blockNumberAccountStr.split(",");
                const blockNumber = parseInt(blockNumberStr);
                const account = yield (0, utils_1.getAccountData)(blockNumber, address, [], this.config.provider);
                blockNumberAccountToAccount[blockNumberAccountStr] = account;
            }
            let queryData = [];
            for (let i = 0; i < sortedQueries.length; i++) {
                const blockNumber = sortedQueries[i].blockNumber;
                if (blockNumber === null) {
                    throw new Error(`Block number cannot be '0' for queries within this set of rows. Row: ${i}`);
                }
                const block = blockNumberToBlock[blockNumber.toString()];
                if (block === null) {
                    throw new Error(`Could not get ${blockNumber} in mapping of blocks`);
                }
                const blockHash = block.hash;
                if (blockHash === null) {
                    throw new Error(`Could not find hash for block ${blockNumber}`);
                }
                const address = sortedQueries[i].address;
                const slot = sortedQueries[i].slot;
                const rowHash = (0, encoder_1.encodeRowHash)(blockNumber, address, slot);
                let row = {
                    rowHash,
                    blockNumber,
                    blockHash,
                };
                if (address !== undefined) {
                    row.address = address;
                    const accountData = blockNumberAccountToAccount[`${blockNumber},${address}`];
                    row.nonce = accountData === null || accountData === void 0 ? void 0 : accountData.nonce;
                    row.balance = accountData === null || accountData === void 0 ? void 0 : accountData.balance;
                    row.storageHash = accountData === null || accountData === void 0 ? void 0 : accountData.storageHash;
                    row.codeHash = accountData === null || accountData === void 0 ? void 0 : accountData.codeHash;
                    if (row.nonce === undefined ||
                        row.balance === undefined ||
                        row.storageHash === undefined ||
                        row.codeHash === undefined) {
                        throw new Error(`Could not find account data for ${address} at block ${blockNumber}`);
                    }
                    row.slot = (_b = (_a = sortedQueries[i].slot) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : undefined;
                    if (slot !== undefined) {
                        row.value =
                            blockNumberAccountStorageToValue[`${blockNumber},${address},${slot}`];
                    }
                }
                queryData.push(row);
            }
            return queryData;
        });
    }
    /// Builds a packed queryData blob from the sorted queries
    buildQueryData(sortedQueries) {
        // Extra data that we'll encode with the query data
        const numQueries = sortedQueries.length;
        const versionIdx = this.config.getConstants().Values.QueryEncodingVersion;
        const encodedQueries = [];
        for (let i = 0; i < numQueries; i++) {
            let length = 0;
            // Check for block number
            const blockNumber = sortedQueries[i].blockNumber;
            if (blockNumber === undefined) {
                const encodedQuery = (0, encoder_1.encodeQuery)(length, 0, ethers_1.ZeroAddress, 0, 0);
                encodedQueries.push(encodedQuery);
                continue;
            }
            // Query has block number; check for address
            length++;
            const address = sortedQueries[i].address;
            if (address === undefined) {
                const encodedQuery = (0, encoder_1.encodeQuery)(length, blockNumber, ethers_1.ZeroAddress, 0, 0);
                encodedQueries.push(encodedQuery);
                continue;
            }
            // Query has block number and address; check for slot
            length++;
            const slot = sortedQueries[i].slot;
            const value = sortedQueries[i].value;
            if (slot === undefined || value === undefined) {
                const encodedQuery = (0, encoder_1.encodeQuery)(length, blockNumber, address, 0, 0);
                encodedQueries.push(encodedQuery);
                continue;
            }
            // Query has all of the fields
            length += 2;
            const encodedQuery = (0, encoder_1.encodeQuery)(length, blockNumber, address, slot, value);
            encodedQueries.push(encodedQuery);
        }
        // Finally return all of the encoded query data
        return (0, encoder_1.encodeQueryData)(versionIdx, numQueries, encodedQueries);
    }
}
exports.QueryBuilder = QueryBuilder;
//# sourceMappingURL=queryBuilder.js.map