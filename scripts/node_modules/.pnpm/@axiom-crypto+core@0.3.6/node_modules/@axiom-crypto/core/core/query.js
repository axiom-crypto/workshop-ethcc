"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Query = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importStar(require("axios"));
const __1 = require("..");
const ethers_1 = require("ethers");
const encoder_1 = require("../query/encoder");
const abi_1 = require("./lib/abi");
const queryBuilder_1 = require("../query/queryBuilder");
const response_1 = require("../query/response");
const version_1 = require("../version");
class Query {
    /**
     * @param config Axiom internal configuration parameters
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * Calls the API to get the QueryData rows for a given Query. Requires either one of
     * keccakQueryResponse or queryHash to be specified.
     * @param keccakQueryResponse (optional) A keccak256 hash of the entire query data blob
     * @param queryHash (optional) A keccak256 hash of the entire query data blob
     * @returns QueryData[] | undefined
     */
    getDataForQuery(keccakQueryResponse, queryHash) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (keccakQueryResponse === undefined && queryHash === undefined) {
                throw new Error("Must specify either keccakQueryResponse or queryHash");
            }
            if (keccakQueryResponse !== undefined && queryHash !== undefined) {
                throw new Error("Cannot specify both keccakQueryResponse and queryHash");
            }
            const baseUrl = this.config.getConstants().Urls.ApiBaseUrl;
            const endpoint = this.config.getConstants().Endpoints.GetDataForQuery;
            const uri = `${baseUrl}${endpoint}`;
            const contractAddress = this.config.getConstants().Addresses.AxiomQuery;
            const headers = {
                "x-axiom-api-key": this.config.apiKey,
                "x-provider-uri": this.config.providerUri,
                "User-Agent": 'axiom-sdk-ts/' + version_1.SDK_VERSION,
            };
            let params;
            if (keccakQueryResponse !== undefined) {
                params = {
                    keccakQueryResponse,
                    chainId: this.config.chainId,
                    contractAddress,
                    mock: this.config.mock,
                };
            }
            else {
                params = {
                    queryHash,
                    chainId: this.config.chainId,
                    contractAddress,
                    mock: this.config.mock,
                };
            }
            const result = yield axios_1.default.get(uri, { params, headers });
            if ((result === null || result === void 0 ? void 0 : result.status) === axios_1.HttpStatusCode.Ok) {
                if ((result === null || result === void 0 ? void 0 : result.data) !== undefined) {
                    return result.data;
                }
            }
            return undefined;
        });
    }
    /**
     * Gets parsed transaction logs from a transaction hash
     * @param txHash Transaction hash from the `sendQuery` call
     * @returns (ethers.LogDescription | null)[]
     */
    getTxLogsForTxHash(txHash) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let tx = yield this.config.provider.getTransactionReceipt(txHash);
            if (!tx) {
                throw new Error("Could not find transaction (ensure you are using the tx hash of the `sendQuery` transaction)");
            }
            let contract = new ethers_1.ethers.Contract(this.config.getConstants().Addresses.Axiom, (0, abi_1.getAxiomQueryAbiForVersion)(this.config.version), this.config.provider);
            let logs = tx.logs.map((log) => contract.interface.parseLog({ data: log.data, topics: log.topics }));
            return logs;
        });
    }
    /**
     * Gets parsed transaction description from a transaction hash
     * @param txHash Transaction hash from the `sendQuery` call
     * @returns ethers.TransactionDescription | null
     */
    getTxDecodedForTxHash(txHash) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let tx = yield this.config.provider.getTransaction(txHash);
            if (!tx) {
                throw new Error("Could not find transaction (ensure you are using the tx hash of the `sendQuery` transaction)");
            }
            let contract = new ethers_1.ethers.Contract(this.config.getConstants().Addresses.Axiom, (0, abi_1.getAxiomQueryAbiForVersion)(this.config.version), this.config.provider);
            let decodedTx = contract.interface.parseTransaction({ data: tx.data, value: tx.value });
            return decodedTx;
        });
    }
    /**
     * Gets a `ResponseTree` for a given queryHash
     * @param keccakQueryResponse A keccak256 hash calculated from the Query
     * @returns ResponseTree
     */
    getResponseTreeForKeccakQueryResponse(keccakQueryResponse) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            keccakQueryResponse = keccakQueryResponse.toLowerCase();
            const data = yield this.getDataForQuery(keccakQueryResponse);
            if (data === undefined) {
                throw new Error(`Could not find query data for ${keccakQueryResponse}`);
            }
            let qb = new queryBuilder_1.QueryBuilder(this.config);
            const responseTree = qb.buildResponseTree(data);
            return responseTree;
        });
    }
    /**
     * Gets a `ResponseTree` for a given queryHash
     * @param queryHash A keccak256 hash of the entire query data blob
     * @returns ResponseTree
     */
    getResponseTreeForQueryHash(queryHash) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            queryHash = queryHash.toLowerCase();
            const data = yield this.getDataForQuery(undefined, queryHash);
            if (data === undefined) {
                throw new Error(`Could not find query data for ${queryHash}`);
            }
            let qb = new queryBuilder_1.QueryBuilder(this.config);
            const responseTree = qb.buildResponseTree(data);
            return responseTree;
        });
    }
    /**
     * Gets a ValidationWitnessResponse, which contains the blockResponse, accountResponse,
     * and storageResponse
     * @param responseTree A `ResponseTree` object
     * @param blockNumber The block number to get the witness for
     * @param address (optional) the address to get the witness for
     * @param slot (optional) the slot to get the witness for
     * @returns ValidationWitnessResponse | undefined
     */
    getValidationWitness(responseTree, blockNumber, address, slot) {
        const rowHash = (0, encoder_1.encodeRowHash)(blockNumber, address, slot);
        const leafIdx = responseTree.rowHashMap.get(rowHash);
        if (leafIdx === undefined) {
            console.log(`Could not find this query in the responseTree`);
            return undefined;
        }
        const rowData = responseTree.data[leafIdx];
        const blockTree = responseTree.blockTree;
        const blockProof = blockTree.getHexProof(blockTree.getLeaf(leafIdx), leafIdx);
        const blockResponse = {
            blockNumber,
            blockHash: rowData.blockHash,
            leafIdx,
            proof: blockProof,
        };
        let accountResponse;
        let storageResponse;
        if (address) {
            const accountTree = responseTree.accountTree;
            const accountProof = accountTree.getHexProof(accountTree.getLeaf(leafIdx), leafIdx);
            if (!rowData.nonce ||
                !rowData.balance ||
                !rowData.storageHash ||
                !rowData.codeHash) {
                return undefined;
            }
            accountResponse = {
                blockNumber,
                addr: address,
                nonce: rowData.nonce,
                balance: rowData.balance,
                storageRoot: rowData.storageHash,
                codeHash: rowData.codeHash,
                leafIdx,
                proof: accountProof,
            };
            if (slot) {
                const storageTree = responseTree.storageTree;
                const storageProof = storageTree.getHexProof(storageTree.getLeaf(leafIdx), leafIdx);
                if (!rowData.value) {
                    return undefined;
                }
                storageResponse = {
                    blockNumber,
                    addr: address,
                    slot,
                    value: rowData.value,
                    leafIdx,
                    proof: storageProof,
                };
            }
        }
        return {
            blockResponse,
            accountResponse,
            storageResponse,
        };
    }
    /**
     * Gets a keccakQueryResponse from the transaction hash (from the `sendQuery` call)
     * @param txHash Transaction hash from the `sendQuery` call
     * @returns keccakQueryResponse | undefined
     */
    getKeccakQueryResponseFromTxHash(txHash) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let logs = yield this.getTxLogsForTxHash(txHash);
            return (_b = (_a = logs[0]) === null || _a === void 0 ? void 0 : _a.args) === null || _b === void 0 ? void 0 : _b.keccakQueryResponse;
        });
    }
    /**
     * Gets a queryHash from a the transaction hash (from the `sendQuery` call)
     * @param txHash Transaction hash from the `sendQuery` call
     * @returns keccakQueryResponse | undefined
     */
    getQueryHashFromTxHash(txHash) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let logs = yield this.getTxLogsForTxHash(txHash);
            return (_b = (_a = logs[0]) === null || _a === void 0 ? void 0 : _a.args) === null || _b === void 0 ? void 0 : _b.queryHash;
        });
    }
    /**
     * Gets a ResponseTree by passing in the transaction hash (from the `sendQuery` call)
     * @param txHash Transaction hash from the `sendQuery` call
     * @returns ResponseTree
     */
    getResponseTreeFromTxHash(txHash) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let decodedTx = yield this.getTxDecodedForTxHash(txHash);
            let query = decodedTx === null || decodedTx === void 0 ? void 0 : decodedTx.args.query;
            let decodedQuery = (0, __1.decodePackedQuery)(query);
            if (!decodedQuery) {
                throw new Error("Could not find query in transaction (ensure you are using the tx hash of the `sendQuery` transaction)");
            }
            let qb = new queryBuilder_1.QueryBuilder(this.config);
            const queryData = yield qb.getQueryDataFromRows(decodedQuery.body);
            const responseTree = qb.buildResponseTree(queryData);
            return responseTree;
        });
    }
    /**
     * A passthrough function that identifies the hash function used in `getBlockResponse`
     * @param blockHash Block hash of the block to use
     * @param blockNumber Block number of the block to use
     * @returns string - Keccak hash of the block response
     */
    getKeccakBlockResponse(blockHash, blockNumber) {
        return (0, response_1.getBlockResponse)(blockHash, blockNumber);
    }
    /**
     * A passthrough function that identifies the hash function used in `getAccountResponse`
     * @param blockNumber Block number of the block to use
     * @param address Address of the account to use
     * @param nonce Nonce of the account
     * @param balance Balance of the account
     * @param storageRoot Storage root (aka storage hash) of the account
     * @param codeHash Code hash of the account
     * @returns string - Keccak hash of the account response
     */
    getKeccakAccountResponse(blockNumber, address, nonce, balance, storageRoot, codeHash) {
        return (0, response_1.getFullAccountResponse)(blockNumber, address, nonce, balance, storageRoot, codeHash);
    }
    /**
     * A passthrough function that identifies the hash function used in `getStorageResponse`
     * @param blockNumber Block number of the block to use
     * @param address Address of the account to use
     * @param slot Slot of the storage in the account
     * @param value Value at that slot
     * @returns string - Keccak hash of the storage response
     */
    getKeccakStorageResponse(blockNumber, address, slot, value) {
        return (0, response_1.getFullStorageResponse)(blockNumber, address, slot, value);
    }
}
exports.Query = Query;
//# sourceMappingURL=query.js.map