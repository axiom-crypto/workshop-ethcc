"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InternalConfig = void 0;
const ethers_1 = require("ethers");
const constants_1 = require("../shared/constants");
class InternalConfig {
    constructor(config, overrides) {
        var _a, _b, _c, _d;
        this.apiKey = (_a = config.apiKey) !== null && _a !== void 0 ? _a : "no-api-key";
        this.providerUri = this.parseProviderUri(config.providerUri);
        this.chainId = (_b = config.chainId) !== null && _b !== void 0 ? _b : 1;
        this.version = this.parseVersion(config.version);
        this.timeoutMs = (_c = config.timeoutMs) !== null && _c !== void 0 ? _c : 10000;
        this.mock = (_d = config.mock) !== null && _d !== void 0 ? _d : false;
        let versionData = (0, constants_1.setVersionData)(this.chainId, this.version, this.mock);
        if (overrides !== undefined) {
            (0, constants_1.updateConstants)(versionData, this.version, overrides);
        }
        this.versionData = Object.freeze(versionData);
        this.provider = new ethers_1.ethers.JsonRpcProvider(this.providerUri);
        if (config.privateKey !== undefined && config.privateKey !== "") {
            this.signer = new ethers_1.ethers.Wallet(config.privateKey, this.provider);
        }
    }
    getConstants() {
        return this.versionData[this.version];
    }
    parseProviderUri(providerUri) {
        if (providerUri === undefined || providerUri === "") {
            throw new Error("providerUri is required in AxiomConfig");
        }
        if (providerUri.startsWith("http://") ||
            providerUri.startsWith("https://")) {
            return providerUri;
        }
        else if (providerUri.startsWith("wss://")) {
            throw new Error("Websockets is not yet supported");
        }
        else {
            throw new Error("Invalid provider URI: URI must start with http://, https://, or wss://");
        }
    }
    parseVersion(version) {
        if (version === undefined) {
            return constants_1.Versions[constants_1.Versions.length - 1];
        }
        let parsedVersion = version.toLowerCase();
        if (!parsedVersion.startsWith("v")) {
            parsedVersion = `v${parsedVersion}`;
        }
        parsedVersion = parsedVersion.replace(/\./g, "_");
        if (constants_1.Versions.includes(parsedVersion)) {
            return parsedVersion;
        }
        throw new Error("Invalid version number. Valid versions are: " + constants_1.Versions.join(", "));
    }
}
exports.InternalConfig = InternalConfig;
//# sourceMappingURL=internalConfig.js.map